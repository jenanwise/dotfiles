## Basic Environment Vars

USERPATH=\
"./node_modules/.bin":\
"$HOME/bin":\
"$HOME/.local/bin":\
"$HOME/node_modules/.bin"

if which /usr/local/bin/brew >/dev/null; then
    BREWPREFIX="$(/usr/local/bin/brew --prefix)"
    EMACSPATH="$(/usr/local/bin/brew --prefix emacs)/bin"
    BREWPATH="$BREWPATH/share/npm/bin":$EMACSPATH:"$BREWPATH/opt/coreutils/libexec/gnubin"
else
    BREWPATH=""
fi

SYSPATH="/usr/local/bin"

export PATH=\
$USERPATH:\
$BREWPATH:\
$SYSPATH:\
$PATH

export AWS_ACCESS_KEY_ID=
export AWS_SECRET_ACCESS_KEY=
export EDITOR="vim"
export GIT_PS1_SHOWDIRTYSTATE=
export GIT_PS1_SHOWSTASHSTATE=1
export LESS="-i -g -M -R -x4 -X -f -F -z-1"
export LEIN_FAST_TRAMPOLINE=y
if which drip > /dev/null; then export LEIN_JAVA_CMD=drip; fi

### Python
if which pyenv > /dev/null; then eval "$(pyenv init -)"; fi

### Golang
# This has to happen during non-interactive setup to work with Emacs.
[[ -s "/Users/jenan/.gvm/scripts/gvm" ]] && source "/Users/jenan/.gvm/scripts/gvm"

[ -z "$PS1" ] && return
##### Interactive setup below this point #####

## Bash settings

# check the window size after each command and, if necessary, update the values
# of LINES and COLUMNS.
shopt -s checkwinsize

shopt -s histappend
export HISTCONTROL=ignoreboth
export HISTSIZE=100000
export HISTFILESIZE=100000
export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"

# vi bindings
set -o vi


## Bash completion

[[ -f /etc/bash_completion ]] && source /etc/bash_completion
[[ -f ~/.bash_completion ]] && source ~/.bash_completion
BREWBASHCOMPLETION="$BREWPREFIX/etc/bash_completion"
if [ -f "$BREWBASHCOMPLETION" ]; then
    . "$BREWBASHCOMPLETION"
fi

# make "g" complete like "git"
complete -o bashdefault -o default -o nospace -F _git g 2>/dev/null \
    || complete -o default -o nospace -F _git g


## Prompt

if [ "$USER" = root ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;31m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
    MAINCOLOR=34;
    if [ -n "`type -t __git_ps1`" ]; then
        PS1='\[\033[01;33m\]$(__git_ps1 "(%s) ")\[\033[01;${MAINCOLOR}m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]$ '
    else
        PS1='\[\033[01;${MAINCOLOR}m\]\u@\h\[\033[00m\]:\[\033[01;36m\]\w\[\033[00m\]$ '
    fi
fi

## fasd/autojump
eval "$(fasd --init auto)"
alias j="fasd_cd -d"
alias jj="fasd_cd -d -i"


## Aliasses

alias cdc="cd \`pwd -P\`"
alias cleanbak='find . -name "*.bak" -exec rm {} \;'
alias cleanpyc='find . -name "*.pyc" -exec rm {} \;'
alias cleanvim='rm $HOME/.viminfo'
alias d='docker'
alias dm-env='eval $(docker-machine env default)'
alias dm-start='docker-machine start default'
alias dm='docker-machine'
alias e="edit"
alias g='git'
alias gorerun='rerun -c --pattern="**/*.go"'
alias groot='cd "`git rev-parse --show-toplevel`"'
alias h="http"
alias httpd="python -m SimpleHTTPServer"
alias ll='ls -l'
alias path='echo $PATH | tr : "\n"'
alias pgctl='pg_ctl -D /usr/local/var/postgres'


## Language setup

## Clojure
export CLOJURE_USER_LIB="$HOME/.clj"

### Ruby
if which rbenv > /dev/null; then eval "$(rbenv init -)"; fi

### Node
export NVM_DIR=~/.nvm
nvm_sh="$(brew --prefix nvm)/nvm.sh"
[[ -s "$nvm_sh" ]] && source "$nvm_sh"

### Python
export WORKON_HOME=~/.virtualenvs
export VIRTUALENV_USE_DISTRIBUTE=1
WRAPPERPATH=``
if which virtualenvwrapper.sh > /dev/null; then source virtualenvwrapper.sh; fi


## Platform-specific setup

if [ `uname` = "Darwin" ]; then
    alias shred="/bin/rm -P"
fi

### Color support for `ls`

# BSD systems have only single-char flags, so -G replaces --color
# To check for this, we run "ls --version" and check the return status.
# BSD's ls will complain and give a non-zero exit status, but Linux's ls
# will happily return with status=0.

if [ "$TERM" != "dumb" ]; then
    if [ `ls --version 2&>/dev/null` ]; then
        eval "`dircolors -b`"
        alias ls='ls --color=auto'
    else
        alias ls='ls -G'
    fi
fi


## SSH

# Add all "id_*" private keys (ignores files ending in .pub) to the ssh agent.
for keyfile in `find ~/.ssh -name "id_rsa" -not -name "*.pub"`; do
    if [ "`ssh-add -l | grep "$keyfile" | wc -l`" = "0" ] ; then
        ssh-add "$keyfile"
    fi
done


## Private env settings

[[ -f ~/.bashrc_local ]] && source ~/.bashrc_local
[[ -f ~/.keys_env ]] && source ~/.keys_env
